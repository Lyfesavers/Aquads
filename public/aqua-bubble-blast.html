<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aqua Bubble Blast</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #0a1429, #1a2744, #2a3f5f);
            overflow: hidden;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .game-container {
            position: relative;
            text-align: center;
        }
        
        canvas {
            border: 3px solid #00ccff;
            border-radius: 15px;
            background: linear-gradient(180deg, #001122, #002244);
            box-shadow: 0 0 50px rgba(0, 204, 255, 0.3);
        }
        
        .ui {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            color: white;
            font-weight: bold;
            z-index: 100;
        }
        
        .ui div {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 10px;
            border: 2px solid #00ccff;
        }
        
        .start-screen {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
        }
        
        .title {
            font-size: 3rem;
            color: #00ccff;
            margin-bottom: 2rem;
            text-shadow: 0 0 20px #00ccff;
        }
        
        .btn {
            background: linear-gradient(45deg, #00ccff, #0099cc);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.2rem;
            border-radius: 25px;
            cursor: pointer;
            margin: 10px;
            transition: transform 0.2s;
        }
        
        .btn:hover {
            transform: scale(1.05);
        }
        
        .instructions {
            position: absolute;
            bottom: 20px;
            color: rgba(255, 255, 255, 0.8);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="ui">
            <div>Score: <span id="score">0</span></div>
            <div>Level: <span id="level">1</span></div>
            <div>Bubbles: <span id="bubbles">20</span></div>
        </div>
        
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div class="start-screen" id="startScreen">
            <div class="title">AQUA BUBBLE BLAST</div>
            <p>Aim and shoot bubbles to match 3 or more!</p>
            <button class="btn" onclick="startGame()">START GAME</button>
        </div>
        
        <div class="instructions">
            ðŸŽ¯ Aim with mouse â€¢ Click to shoot â€¢ Match 3+ bubbles
        </div>
    </div>

    <script>
        class BubbleGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.gameRunning = false;
                
                this.score = 0;
                this.level = 1;
                this.bubblesLeft = 20;
                
                this.bubbleRadius = 20;
                this.colors = ['#ff4757', '#ffa726', '#ffeb3b', '#4caf50', '#26c6da', '#42a5f5'];
                
                // Grid settings for proper hexagonal layout
                this.gridCols = 15;
                this.gridRows = 12;
                this.tileWidth = this.bubbleRadius * 2;
                this.tileHeight = this.bubbleRadius * 2;
                this.rowHeight = this.bubbleRadius * 1.75; // Tighter vertical spacing
                this.rowOffset = 0; // Used for shifting rows
                
                this.shooter = {
                    x: this.canvas.width / 2,
                    y: this.canvas.height - 40,
                    angle: 0,
                    currentBubble: null
                };
                
                // Grid-based bubble storage
                this.grid = [];
                this.shootingBubble = null;
                this.particles = [];
                
                this.init();
            }
            
            init() {
                this.setupEventListeners();
                this.generateLevel();
                this.createShooterBubble();
                this.gameLoop();
            }
            
            setupEventListeners() {
                this.canvas.addEventListener('mousemove', (e) => {
                    if (!this.gameRunning) return;
                    const rect = this.canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    this.shooter.angle = Math.atan2(mouseY - this.shooter.y, mouseX - this.shooter.x);
                });
                
                this.canvas.addEventListener('click', () => {
                    if (this.gameRunning) this.shoot();
                });
            }
            
            initGrid() {
                // Initialize empty grid
                this.grid = [];
                for (let col = 0; col < this.gridCols; col++) {
                    this.grid[col] = [];
                    for (let row = 0; row < this.gridRows; row++) {
                        this.grid[col][row] = null;
                    }
                }
            }
            
            generateLevel() {
                this.initGrid();
                const rows = Math.min(5 + this.level, 8);
                
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < this.gridCols; col++) {
                        if (Math.random() > 0.3) {
                            const coords = this.getGridCoordinates(col, row);
                            if (coords.x + this.bubbleRadius < this.canvas.width) {
                                this.grid[col][row] = {
                                    color: this.colors[Math.floor(Math.random() * this.colors.length)],
                                    col: col,
                                    row: row
                                };
                            }
                        }
                    }
                }
            }
            
            getGridCoordinates(col, row) {
                let x = col * this.tileWidth + this.bubbleRadius;
                const y = row * this.rowHeight + this.bubbleRadius + 50;
                
                // Offset every other row for hexagonal pattern
                if ((row + this.rowOffset) % 2 === 1) {
                    x += this.bubbleRadius;
                }
                
                return { x: x, y: y };
            }
            
            getGridPosition(x, y) {
                const adjustedY = y - 50;
                const row = Math.round(adjustedY / this.rowHeight);
                
                let adjustedX = x;
                if ((row + this.rowOffset) % 2 === 1) {
                    adjustedX -= this.bubbleRadius;
                }
                
                const col = Math.round((adjustedX - this.bubbleRadius) / this.tileWidth);
                
                return { col: Math.max(0, Math.min(col, this.gridCols - 1)), 
                        row: Math.max(0, Math.min(row, this.gridRows - 1)) };
            }
            
            createShooterBubble() {
                this.shooter.currentBubble = {
                    color: this.colors[Math.floor(Math.random() * this.colors.length)],
                    x: this.shooter.x,
                    y: this.shooter.y
                };
            }
            
            shoot() {
                if (!this.shooter.currentBubble || this.shootingBubble) return;
                
                const speed = 8;
                this.shootingBubble = {
                    x: this.shooter.x,
                    y: this.shooter.y,
                    vx: Math.cos(this.shooter.angle) * speed,
                    vy: Math.sin(this.shooter.angle) * speed,
                    color: this.shooter.currentBubble.color,
                    radius: this.bubbleRadius,
                    moving: true
                };
                
                this.bubblesLeft--;
                this.createShooterBubble();
                this.updateUI();
            }
            
            update() {
                // Update shooting bubble
                if (this.shootingBubble && this.shootingBubble.moving) {
                    const bubble = this.shootingBubble;
                    
                    bubble.x += bubble.vx;
                    bubble.y += bubble.vy;
                    
                    // Wall bounce
                    if (bubble.x <= this.bubbleRadius) {
                        bubble.x = this.bubbleRadius;
                        bubble.vx *= -1;
                    } else if (bubble.x >= this.canvas.width - this.bubbleRadius) {
                        bubble.x = this.canvas.width - this.bubbleRadius;
                        bubble.vx *= -1;
                    }
                    
                    // Hit ceiling
                    if (bubble.y <= this.bubbleRadius + 50) {
                        this.attachBubble(bubble.x, bubble.y, bubble.color);
                        return;
                    }
                    
                    // Check collision with grid bubbles
                    if (this.checkGridCollision(bubble)) {
                        this.attachBubble(bubble.x, bubble.y, bubble.color);
                        return;
                    }
                }
                
                // Update particles
                this.particles = this.particles.filter(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.3;
                    p.life -= 0.02;
                    return p.life > 0;
                });
                
                // Update level complete message
                if (this.levelCompleteMessage) {
                    this.levelCompleteMessage.time -= 16; // Assuming 60fps
                    this.levelCompleteMessage.alpha = Math.max(0, this.levelCompleteMessage.time / 2000);
                    
                    if (this.levelCompleteMessage.time <= 0) {
                        this.levelCompleteMessage = null;
                    }
                }
            }
            
            checkGridCollision(bubble) {
                for (let col = 0; col < this.gridCols; col++) {
                    for (let row = 0; row < this.gridRows; row++) {
                        if (this.grid[col][row]) {
                            const coords = this.getGridCoordinates(col, row);
                            const dx = coords.x - bubble.x;
                            const dy = coords.y - bubble.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < this.bubbleRadius * 2) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            
            attachBubble(x, y, color) {
                const gridPos = this.getGridPosition(x, y);
                
                // Find nearest empty position
                const nearestPos = this.findNearestEmptyPosition(gridPos.col, gridPos.row);
                
                if (nearestPos) {
                    this.grid[nearestPos.col][nearestPos.row] = {
                        color: color,
                        col: nearestPos.col,
                        row: nearestPos.row
                    };
                    
                    this.shootingBubble = null;
                    
                    // Check matches after a short delay to allow for visual feedback
                    setTimeout(() => this.checkMatches(nearestPos.col, nearestPos.row), 50);
                }
            }
            
            findNearestEmptyPosition(targetCol, targetRow) {
                // Start with the target position if it's empty
                if (!this.grid[targetCol] || !this.grid[targetCol][targetRow]) {
                    return { col: targetCol, row: targetRow };
                }
                
                // Search in expanding rings around the target
                for (let radius = 1; radius <= 3; radius++) {
                    for (let col = Math.max(0, targetCol - radius); col <= Math.min(this.gridCols - 1, targetCol + radius); col++) {
                        for (let row = Math.max(0, targetRow - radius); row <= Math.min(this.gridRows - 1, targetRow + radius); row++) {
                            if (!this.grid[col][row]) {
                                // Check if this position has at least one neighbor (not floating)
                                const neighbors = this.getNeighbors(col, row);
                                const hasNeighbor = neighbors.some(n => this.grid[n.col] && this.grid[n.col][n.row]);
                                
                                if (hasNeighbor || row === 0) { // Top row is always valid
                                    return { col: col, row: row };
                                }
                            }
                        }
                    }
                }
                
                return null;
            }
            
            getNeighbors(col, row) {
                const neighbors = [];
                
                // Hexagonal neighbor offsets
                const evenRowOffsets = [[-1, -1], [0, -1], [-1, 0], [1, 0], [-1, 1], [0, 1]];
                const oddRowOffsets = [[0, -1], [1, -1], [-1, 0], [1, 0], [0, 1], [1, 1]];
                
                const offsets = (row % 2 === 0) ? evenRowOffsets : oddRowOffsets;
                
                for (const [dx, dy] of offsets) {
                    const newCol = col + dx;
                    const newRow = row + dy;
                    
                    if (newCol >= 0 && newCol < this.gridCols && newRow >= 0 && newRow < this.gridRows) {
                        neighbors.push({ col: newCol, row: newRow });
                    }
                }
                
                return neighbors;
            }
            
            checkMatches(col, row) {
                const bubble = this.grid[col][row];
                if (!bubble) return;
                
                const matches = this.findConnectedBubbles(col, row, bubble.color);
                
                if (matches.length >= 3) {
                    // Remove matched bubbles
                    matches.forEach(pos => {
                        this.grid[pos.col][pos.row] = null;
                    });
                    
                    this.score += matches.length * 10;
                    this.createParticlesFromGrid(matches);
                    
                    // Remove floating bubbles after a match
                    setTimeout(() => {
                        this.removeFloatingBubbles();
                    }, 150);
                }
                
                this.checkWin();
            }
            
            findConnectedBubbles(startCol, startRow, targetColor) {
                const visited = new Set();
                const matches = [];
                const toCheck = [{ col: startCol, row: startRow }];
                
                while (toCheck.length > 0) {
                    const current = toCheck.pop();
                    const key = `${current.col},${current.row}`;
                    
                    if (visited.has(key)) continue;
                    visited.add(key);
                    
                    const bubble = this.grid[current.col] && this.grid[current.col][current.row];
                    if (!bubble || bubble.color !== targetColor) continue;
                    
                    matches.push(current);
                    
                    // Check all neighbors
                    const neighbors = this.getNeighbors(current.col, current.row);
                    for (const neighbor of neighbors) {
                        const neighborKey = `${neighbor.col},${neighbor.row}`;
                        if (!visited.has(neighborKey)) {
                            toCheck.push(neighbor);
                        }
                    }
                }
                
                return matches;
            }
            
            removeBubbles(bubbles) {
                bubbles.forEach(bubble => {
                    const index = this.bubbles.indexOf(bubble);
                    if (index > -1) this.bubbles.splice(index, 1);
                });
            }
            
            removeFloatingBubbles() {
                const connected = new Set();
                const toCheck = [];
                
                // Find all bubbles connected to the top row
                for (let col = 0; col < this.gridCols; col++) {
                    if (this.grid[col][0]) {
                        toCheck.push({ col: col, row: 0 });
                    }
                }
                
                // Use BFS to find all connected bubbles
                while (toCheck.length > 0) {
                    const current = toCheck.pop();
                    const key = `${current.col},${current.row}`;
                    
                    if (connected.has(key)) continue;
                    connected.add(key);
                    
                    const neighbors = this.getNeighbors(current.col, current.row);
                    for (const neighbor of neighbors) {
                        const neighborKey = `${neighbor.col},${neighbor.row}`;
                        if (!connected.has(neighborKey) && this.grid[neighbor.col] && this.grid[neighbor.col][neighbor.row]) {
                            toCheck.push(neighbor);
                        }
                    }
                }
                
                // Remove floating bubbles
                const floatingBubbles = [];
                for (let col = 0; col < this.gridCols; col++) {
                    for (let row = 0; row < this.gridRows; row++) {
                        if (this.grid[col][row] && !connected.has(`${col},${row}`)) {
                            floatingBubbles.push({ col: col, row: row });
                            this.grid[col][row] = null;
                        }
                    }
                }
                
                if (floatingBubbles.length > 0) {
                    this.score += floatingBubbles.length * 5; // Bonus points for floating bubbles
                    this.createParticlesFromGrid(floatingBubbles);
                    this.updateUI();
                }
            }
            
            createParticles(bubbles) {
                bubbles.forEach(bubble => {
                    for (let i = 0; i < 6; i++) {
                        this.particles.push({
                            x: bubble.x,
                            y: bubble.y,
                            vx: (Math.random() - 0.5) * 8,
                            vy: (Math.random() - 0.5) * 8,
                            color: bubble.color,
                            life: 1
                        });
                    }
                });
            }
            
            createParticlesFromGrid(gridPositions) {
                gridPositions.forEach(pos => {
                    const coords = this.getGridCoordinates(pos.col, pos.row);
                    const bubble = this.grid[pos.col] && this.grid[pos.col][pos.row];
                    
                    for (let i = 0; i < 6; i++) {
                        this.particles.push({
                            x: coords.x,
                            y: coords.y,
                            vx: (Math.random() - 0.5) * 8,
                            vy: (Math.random() - 0.5) * 8,
                            color: bubble ? bubble.color : this.colors[0],
                            life: 1
                        });
                    }
                });
            }
            
            checkWin() {
                let remaining = 0;
                for (let col = 0; col < this.gridCols; col++) {
                    for (let row = 0; row < this.gridRows; row++) {
                        if (this.grid[col][row]) {
                            remaining++;
                        }
                    }
                }
                
                if (remaining === 0) {
                    // Level completed!
                    this.score += 100 * this.level; // Bonus points for completing level
                    this.showLevelComplete();
                    
                    setTimeout(() => {
                        this.level++;
                        this.bubblesLeft = Math.max(15, 25 - this.level); // Fewer bubbles at higher levels
                        this.generateLevel();
                        this.updateUI();
                    }, 2000);
                } else if (this.bubblesLeft <= 0) {
                    this.gameRunning = false;
                    alert(`Game Over! Final Score: ${this.score}\nReached Level: ${this.level}`);
                    document.getElementById('startScreen').style.display = 'flex';
                }
                
                this.updateUI();
            }
            
            draw() {
                // Clear canvas
                this.ctx.fillStyle = 'rgba(0, 17, 34, 0.1)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw aim line
                if (this.gameRunning && this.shooter.currentBubble) {
                    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.shooter.x, this.shooter.y);
                    this.ctx.lineTo(
                        this.shooter.x + Math.cos(this.shooter.angle) * 100,
                        this.shooter.y + Math.sin(this.shooter.angle) * 100
                    );
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                }
                
                // Draw grid bubbles
                for (let col = 0; col < this.gridCols; col++) {
                    for (let row = 0; row < this.gridRows; row++) {
                        if (this.grid[col][row]) {
                            const coords = this.getGridCoordinates(col, row);
                            this.drawBubbleAt(coords.x, coords.y, this.grid[col][row].color);
                        }
                    }
                }
                
                // Draw shooting bubble
                if (this.shootingBubble) {
                    this.drawBubbleAt(this.shootingBubble.x, this.shootingBubble.y, this.shootingBubble.color);
                }
                
                // Draw shooter bubble
                if (this.shooter.currentBubble) {
                    this.drawBubbleAt(this.shooter.currentBubble.x, this.shooter.currentBubble.y, this.shooter.currentBubble.color);
                }
                
                // Draw particles
                this.particles.forEach(particle => {
                    this.ctx.save();
                    this.ctx.globalAlpha = particle.life;
                    this.ctx.fillStyle = particle.color;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.restore();
                });
                
                // Draw level complete message
                if (this.levelCompleteMessage) {
                    this.ctx.save();
                    this.ctx.globalAlpha = this.levelCompleteMessage.alpha;
                    this.ctx.fillStyle = '#00ccff';
                    this.ctx.font = 'bold 48px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.strokeStyle = '#ffffff';
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeText(this.levelCompleteMessage.text, this.canvas.width / 2, this.canvas.height / 2);
                    this.ctx.fillText(this.levelCompleteMessage.text, this.canvas.width / 2, this.canvas.height / 2);
                    this.ctx.restore();
                }
            }
            
            drawBubbleAt(x, y, color) {
                // Glow effect
                this.ctx.save();
                this.ctx.shadowColor = color;
                this.ctx.shadowBlur = 10;
                
                // Main bubble
                this.ctx.fillStyle = color;
                this.ctx.beginPath();
                this.ctx.arc(x, y, this.bubbleRadius, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Highlight
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                this.ctx.beginPath();
                this.ctx.arc(x - 5, y - 5, this.bubbleRadius * 0.3, 0, Math.PI * 2);
                this.ctx.fill();
                
                this.ctx.restore();
            }
            
            showLevelComplete() {
                // Create celebration particles
                for (let i = 0; i < 30; i++) {
                    this.particles.push({
                        x: this.canvas.width / 2,
                        y: this.canvas.height / 2,
                        vx: (Math.random() - 0.5) * 15,
                        vy: (Math.random() - 0.5) * 15,
                        color: this.colors[Math.floor(Math.random() * this.colors.length)],
                        life: 1.5
                    });
                }
                
                // Show level complete message
                this.levelCompleteMessage = {
                    text: `LEVEL ${this.level} COMPLETE!`,
                    alpha: 1,
                    time: 2000
                };
            }
            
            updateUI() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('level').textContent = this.level;
                document.getElementById('bubbles').textContent = this.bubblesLeft;
            }
            
            gameLoop() {
                if (this.gameRunning) this.update();
                this.draw();
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        let game;
        
        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            game = new BubbleGame();
            game.gameRunning = true;
        }
        
        // Initialize
        window.addEventListener('load', () => {
            game = new BubbleGame();
        });
    </script>
</body>
</html> 